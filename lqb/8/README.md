# 第八届蓝桥杯真题解题报告

<span id = "0">目录：</span>
1. [购物单](#1)
2. [等差素数列](#2)
3. [承压计算](#3)

[<span id = "1">1. 购物单</span>](#0)

    小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。

    这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。
    小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。
    现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。

    取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。
    你的任务是计算出，小明最少需要取多少现金。

以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。
```
-----------------
****     180.90       88折
****      10.25       65折
****      56.14        9折
****     104.65        9折
****     100.30       88折
****     297.15        半价
****      26.75       65折
****     130.62        半价
****     240.28       58折
****     270.62        8折
****     115.87       88折
****     247.34       95折
****      73.21        9折
****     101.00        半价
****      79.54        半价
****     278.44        7折
****     199.26        半价
****      12.97        9折
****     166.30       78折
****     125.50       58折
****      84.98        9折
****     113.35       68折
****     166.57        半价
****      42.56        9折
****      81.90       95折
****     131.78        8折
****     255.89       78折
****     109.17        9折
****     146.69       68折
****     139.33       65折
****     141.16       78折
****     154.74        8折
****      59.42        8折
****      85.44       68折
****     293.70       88折
****     261.79       65折
****      11.30       88折
****     268.27       58折
****     128.29       88折
****     251.03        8折
****     208.39       75折
****     128.88       75折
****      62.06        9折
****     225.87       75折
****      12.89       75折
****      34.28       75折
****      62.16       58折
****     129.12        半价
****     218.37        半价
****     289.69        8折
--------------------
```

需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。
特别地，半价是按50%计算。
请提交小明要从取款机上提取的金额，单位是元。
答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。

特别提醒：不许携带计算器入场，也不能打开手机。

解：
思路：这题直接代码解决，先将数据处理一下，去除\*\*\*\*和'折'字, 然后直接作为数据输入

```cpp
#include <iostream>
using namespace std;

int main(){
	double value, sum = 0;
	int discount;
	while(cin >> value && value != -1){   //输入-1结束
		cin >> discount;
		if(discount % 10 == 0)    //如果是8折、9折就换成80、90,便于后面计算
			discount *= 10;
		sum += value * discount / 100;  //每一次折扣后的费用都加起来
	}
	int a = sum / 100;   //取出整百部分
	if(sum - a * 100 > 0)    //如果费用不是整百，那么a + 1，表示将整百部分+1, 4301=>4400
		cout << (a + 1) * 100 << endl;
	else 
		cout << a * 100 << endl;
	return 0;
}
```
答案：9700
---

[<span id = "2">2. 等差素数列</span>](#0)
2,3,5,7,11,13,....是素数序列。
类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。
上边的数列公差为30，长度为6。
2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。
这是数论领域一项惊人的成果！
有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：
长度为10的等差素数列，其公差最小值是多少？
注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。

解：
思路：暴力枚举每一个素数，每次得到一个素数，就从1-1000循环公差, 如果在该公差下的十个数都是素数，那么最小值就是该公差

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

bool sushu(int n){    //求素数
	for(int i = 2; i <= sqrt(n); i++){
		if(n % i == 0)
			return false;
	}
	return true;
}

int main(){
	int a;
	for(int i = 2; i < 100000; i++){
		if(sushu(i)){   //如果该数是素数
			for(int j = 2; j < 1000; j += 2){  //素数的公差不可能为奇数，因为除2外的素数都是奇数，奇数+奇数=偶数
				int p;
				for(p = 0; p < 10; p++)   //在公差为j的情况下，遍历后面的10个数
					if(!sushu(i + j * p))   //如果某一个不是素数，则跳出循环
						break;
				if(p == 10){       //10个数为素数，输出
					cout << j << endl;
				}
			}
		}
	}
	return 0;
}
```

答案：210
---

[<span id = "3">3. 承压计算</span>](#0)

X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。
每块金属原料的外形、尺寸完全一致，但重量不同。
金属材料被严格地堆放成金字塔形。
```
                             7 
                            5 8 
                           7 8 8 
                          9 2 7 2 
                         8 1 4 9 1 
                        8 1 8 8 4 1 
                       7 9 6 1 4 5 4 
                      5 6 5 5 6 9 5 6 
                     5 5 4 7 9 3 5 5 1 
                    7 5 7 9 7 4 7 3 3 1 
                   4 6 4 5 5 8 8 3 2 4 3 
                  1 1 3 3 1 6 6 5 5 4 4 2 
                 9 9 9 2 1 9 1 9 2 9 5 7 9 
                4 3 3 7 7 9 3 6 1 3 8 8 3 7 
               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 
              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 
             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 
            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 
           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 
          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 
         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 
        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 
       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 
      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 
     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 
    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 
   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 
  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 
 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 
X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 
```
其中的数字代表金属块的重量（计量单位较大）。
最下一层的X代表30台极高精度的电子秤。

假设每块原料的重量都十分精确地平均落在下方的两个金属块上，
最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。
电子秤的计量单位很小，所以显示的数字很大。
工作人员发现，其中读数最小的电子秤的示数为：2086458231
请你推算出：读数最大的电子秤的示数为多少？
注意：需要提交的是一个整数，不要填写任何多余的内容。

解：
思路：上面一个数字平均分到它下面的两个数字上，直接用二维数组存下所有数字，然后每一行的数字等于当前的数字加上它上面两个数字的一半
例如：
```
  1         1
 2 3    =>  2 3 
4 5 6       4 5 6
```
当上面的重量落下来的时候，第二行的2就变为2 + 1 / 2 = 2.5, 第三行的4就变为4 + 2.5 / 2
一直算到最后一行，取出最大和最小的两个数，那么读数最大的示数应为MAX * 2086458231 / MIN

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main(){
	double a[31][31];
	memset(a, 0, sizeof(a));
	for(int i = 1; i <= 29; i++)
		for(int j = 1;j <= i; j++)
			cin >> a[i][j];
	for(int i = 2; i <= 29; i++)
		for(int j = 1; j <= 29; j++){
			a[i][j] += a[i - 1][j - 1] / 2 + a[i - 1][j] / 2;   //下面一个数=正上的左边一个数/2+正上面的数/2
		}
	double MIN = 9999999, MAX = 0; 
	for(int i = 1; i <= 30; i++){
		a[30][i] = a[29][i - 1] / 2 + a[29][i] / 2;   //求出第30行的X的数字
		MIN = min(MIN, a[30][i]);    //求出最小值
		MAX = max(MAX, a[30][i]);    //求出最大值
	}
	cout << fixed << MAX * 2086458231 / MIN << endl;   //fixed格式化输出，使其以小数形式输出
	return 0;
}

```

答案：72665192664
---


